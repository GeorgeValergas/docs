#Amazon Web Services

###%st stat in "top"
The %st stat in "top" shows you much much time other VMs are stealing time from your CPU. "st" stands for
‘Steal Time’ and is the amount of real cpu that the Xen Hypervisor has allocated to tasks other than
running your Virtual Machine (such as somebody else’s VM...).

Amazon uses steal time to throttle your CPU back to the rate allocated for your instance, regardless
of what other VMs are running on the hardware. (i.e. Amazon doesn't let you have more CPU than you've
purchased). This is readily apparent on t1.micro instances after your CPU burst time is exceeded. In this
case steal time pegs at 98% for the remainder of the CPU intensive task, effectively crippling your instance.

    top - 21:26:59 up 4 min,  1 user,  load average: 0.82, 1.22, 0.61
    Tasks:  95 total,   1 running,  94 sleeping,   0 stopped,   0 zombie
    Cpu(s):  0.0%us,  0.3%sy,  0.0%ni, 98.3%id,  0.0%wa,  0.0%hi,  0.0%si,  1.3%st
    Mem:   1757264k total,   323224k used,  1434040k free,    13452k buffers
    Swap:   917496k total,        0k used,   917496k free,    97284k cached

###EBS performance and MySQL data
There is mixed information on the performance of the instance (ephemeral) storage vs EBS. It appears that
EBS performance may be better on average but EBS has high variability in random seek times. If EBS
performance becomes a factor, storing the database in instance storage is an option to consider. But if
we place the database in instance storage, backups must be done with mysqldump and s3 buckets. This has
performance implications. mysqldump creates a significant load on MySQL. Plus it's not clear how we
can get a consistent snapshot of the database while it's still active. Backups generated by mysqldump
also can take a long time to restore.

###AWS Micro (t1.micro) instances
While it may be tempting to use a t1.micro instance for a small Rails app, a t1.micro instance is probably
not practical for any true customer-facing Rails server. The problem is the CPU resources are allocated
in bursts on a t1.micro instance. When not bursting, the steady-state CPU capacity of the instance very
low - about 2% of the burst capacity. If your app does anything CPU intensive for more than ~10 seconds,
your instance CPU is scaled **WAY** back - to about 2% of the burst capacity. This effectively cripples
your server until the CPU-intensive task finishes and the load drops. But since your server is now crawling
along, it may take a long time for the task to finish. If new requests come in during this time, it just
compounds the problem.

If several users visit your app simultaneously, or a bot scans your site, your CPU burst limit can easily be
reached. In addition, background tasks such as munin-node updates or mysqldump can exceed the CPU burst limit
causing significant slowdowns for app users.

Another effect of CPU bursting is that t1.micro instances take several hours to bootstrap with Rubber (vs
~20 minutes on a m1.small instance) because of all the CPU intensive work required.

Greg Wilson provides a good illustration of CPU limiting in the real world in [this blog entry](http://gregsramblings.com/2011/02/07/amazon-ec2-micro-instance-cpu-steal/).
There is a good technical writeup of CPU limiting in [Amazon's official documentation](http://docs.amazonwebservices.com/AWSEC2/latest/UserGuide/index.html?concepts_micro_instances.html)

###AWS mounts secondary instance storage to /mnt
All AWS instances are given secondary instance storage (150GB for m1.small instances). By default this
storage is mounted on `/mnt`. This storage is free, but will go away when the instances fails or is
terminated. So it should not be used for essential assets. Because `/mnt` is already taken, you cannot
easily mount an EBS volume to `/mnt` using Rubber.

Exception: AWS does not provide secondary instance storage for t1.micro instances. In this case the `/mnt`
mount point is available for an EBS volume.
#Overview
This documents contains instructions for using Rubber to prepare an app with a basic framework
for a single server deployment on AWS.

##Prepare the app
Add the following lines to config/boot.rb.

    require 'yaml'
    YAML::ENGINE.yamler= 'syck'
    
If you don't have a "secrets" folder already in your app, create a folder to hold secret files
that you don't want checked into version control.

    mkdir -p config/secrets
    
Add the following lines to your Gemfile and update your gems with "`bundle install`"

    gem 'rubber', :git => "git://github.com/willkoehler/rubber.git"

##Vulcanize the app to setup the necessary files for Rubber.
We vulcanize each role manually, rather than use an all-in-one generator like "`complete_passenger_mysql`"

    bundle exec vulcanize minimal_passenger_nginx
    bundle exec vulcanize mysql
    bundle exec vulcanize munin
    bundle exec vulcanize monit

##Create config/secrets/rubber-secret.yml
Values entered into `rubber-secret.yml` override corresponding values in `rubber.yml`. Put your AWS
access credentials and other things that you don't want checked into version control in this
file. The contents of this file should look like:

    admin_email: your@email.com

    cloud_providers:
      aws:
        access_key: XXX
        secret_access_key: YYY
        account: Your AWS account ID (digits only, no dashes)
        key_name: your-keypair
        key_file: "#{File.join(RUBBER_ROOT, 'config', 'secrets', cloud_providers.aws.key_name)}"

You can get your Access Credentials and AccountID (`access_key`, `secret_access_key`, `account`) from your
[AWS Account - Security Credentials](https://aws-portal.amazon.com/gp/aws/developer/account/index.html?action=access-key&tabId=id_block#access_credentials) page

The `key_name` parameter is the name of the key pair to use for the instance. Key pairs are generated by AWS on demand
and are used to authenticate ssh logins to the instance once it's created. Think of it as a very long password for the instance.
You can create one key pair and share it among all your instances or create a different key pair for each instance. Read more about
these key pairs on the [About AWS Security Credentials](http://docs.amazonwebservices.com/AWSSecurityCredentials/1.0/AboutAWSCredentials.html#EC2KeyPairs) page.
AWS only gives you the private key portion of the key pair, and only gives you this file once, just after you create it.
It's up to you to save the key file after that. You need to remove the ".pem" extension from the key file and place it in
the config/secrets folder in your app. You then need to create a public key from the private key using the following command:

    ssh-keygen -y -f config/secrets/your-keypair > config/secrets/your-keypair.pub

##Edit rubber.yml to customize your server configuration
Enter all REQUIRED parameters (except AWS access credentials which you defined above) Below are more
details on some of the required parameters.

###Chose your instance type
Tell Rubber what type of instance to create (`image_type`) and what AMI to use as a basis for the instance
(`image_id`). You can find the latest official Ubuntu AMIs here: [http://alestic.com/](http://alestic.com/)
It's always best to check alestic.com for the latest AMIs because they change often. I recommend using Ubuntu
10.04 LTS Lucid EBS boot.

    image_type: m1.small
    image_id: ami-61be7908    # Check alestic.com for latest AMI 

###Setup web tools username and password
Setup a username and password to control access to the web tools (munin/monit). Uncomment the following
lines and add your own username and password.

    web_tools_user: admin
    web_tools_password: yourpw

###Disable auto security groups
By default, Rubber creates security group for all possible server roles in case they are needed in the future.
(AWS doesn't allow you to assign new security groups after you create an instance.) This is not needed in our
case so set `auto_security_groups` to false

    auto_security_groups: false

###Tell Rubber to use rubber-secret.yml
Uncomment the following line and point it to your copy of `rubber-secret.yml`

    rubber_secret: "#{File.join(RUBBER_ROOT, 'config', 'secrets', 'rubber-secret.yml')}"

###Define your hosts and EBS volumes
The host configuration tells rubber which instances are included in your deployment. For our purposes, we are
setting up a single instance.

    hosts:
      cms1:
        instance_roles: "web,app,web_tools,db:primary=true"
        availability_zone: us-east-1b
        use_static_ip: true     # If you want this instance to have a static IP
        volumes:                # (Optional: define one or more EBS volumes)
          - size: 100           # size of vol in GBs
            zone: us-east-1b    # zone to create volume in, needs to match host's zone
            device: /dev/sdh    # OS device to attach volume to
            mount: /ebs         # The directory to mount this volume to
            filesystem: ext3    # the filesystem to create on volume

Under each instance you can define one or more EBS volumes to be created and mounted on the instance.
It's up to you what volumes and mount points to use and what assets to store on the mount points. Rubber
gives you lot of flexibility where assets are places on your server via the various config files.
There is only one **IMPORTANT CAVEAT**: the mount point `/mnt` is already taken by the secondary instance
storage. If you try to use this mount point, Rubber will will create an EBS volume and attach it to your
instance, but silently fail to mount your EBS volume when it discovers that `/mnt` is already taken.

One simple configuration is to mount an EBS volume on `/ebs` and move all assets to `/ebs` by doing a global
search and replace in your app, replacing `"/mnt/"` with `"/ebs/"`

##Edit rubber-passenger_nginx.yml and change the HTTP ports
Rubber assumes haproxy is always installed and sets up the HTTP ports accordingly. Since we are not using haproxy
at this time, we need to tell passenger to listen on ports 80,443

    passenger_listen_port: 80
    passenger_listen_ssl_port: 443
    
##Edit deploy.rb and enable push\_instance\_config
When `push_instance_config` is enabled, Rubber pushes `instance-production.yml` directly to the server during
deploy, overriding the version checked into git. If we didn't use this, we would need to check in changes to
`instance-production.yml` and push them to github after each deploy step.

    set :push_instance_config, true
    
##Backups via EBS snapshots (optional)
EBS snapshots provide an excellent backup mechanism for applications running on AWS.
The task below is hardcoded to work with a single-server deployment with a single EBS
volume and MySQL database. To use EBS snapshots, add the system:backup task to your
rake file

    require "AWS"

    namespace :system do
      desc "Server backup. Database and all user data will be backed up"
      task :backup => :environment do
        # Flush and lock all the DB tables. Rails will block on actions that write to the DB
        # until the tables are unlocked. This should be transparent to web users, asside from
        # a short delay in the app response time. Entire :backup task only takes a few seconds.
        ActiveRecord::Base.establish_connection
        ActiveRecord::Base.connection.execute("FLUSH TABLES WITH READ LOCK")
        # Fush Ext3 file system cache to disk
        system("sync")
        # Create EBS snapshot. We only have one instance and one EBS volume, just select that volume
        ec2 = AWS::EC2::Base.new(:access_key_id => cloud_provider.access_key, :secret_access_key => cloud_provider.secret_access_key)
        volume_id = rubber_instances.first.volumes.first
        ec2.create_snapshot(volume_id: volume_id, description: "Nightly backup of /ebs on #{rubber_instances.first.full_name}")
        # unlock tables
        ActiveRecord::Base.connection.execute("UNLOCK TABLES")
      end
    end
    
Add a cron job to `config/rubber/common/crontab` to run system:backup nightly

    # Backup server at 1:30am
    30 1 * * * <%= RUBBER_ROOT %>/script/cron-rake system:backup

Disable the Rubber-provided backup cron job defined in `config/rubber/role/db/crontab`

    #(disabled) 0 */3 * * * BACKUP_DIR=/ebs/db_backups DBUSER=<%= rubber_env.db_user %> ...


NOTE: EBS snapshot backups are required for the last two recovery methods described below.


##Create the server and deploy the application.

    bundle exec cap rubber:create        # creates the instance on AWS
    bundle exec cap rubber:bootstrap     # sets up the instance, installs all require packages, ruby, etc
    bundle exec cap deploy               # deploy the app
    bundle exec cap deploy:migrate       # (if needed) to install db migrations

During the rubber:create step you will be asked for two pieces of information:

* **Instance alias**: This is the alias of the server you want to create. In our case, we defined a single
alias (cms1) so enter that here. It's possible to define several hosts in `rubber.yml` and create
them all at once here.

* **Instance roles**: Just press enter to accept the defaults you configured in `instance_rolls` in `rubber.yml`

The entire creation and deployment process takes about 25 minutes with the bulk of the time in the bootstrap step.

**NOTE: Check the console output carefully for errors after each step.** You don't need to scan the entire
console output, just the last few lines. Rubber is good about stopping if there is an error and will display
a meaningful error message. But with so much console output you might not notice unless you pay attention.
Error missed during bootstrap and deploy can lead to strange problems that are very difficult to diagnose later on.

##Connect to the new instance via SSH

    ssh -i config/secret/your-keypair-name root@your.server.url

##Recovering if an instance crashes
If an instance crashes, Rubber allows you to create a new instance and remount your EBS volumes on the new
instance. All assets on the EBS volumes will be preserved. The static IP associated with the instance will
also be preserved and reused when you recreate the instance.

Tell Rubber the instance has crashed by destroying it.

    bundle exec cap rubber:destroy
    
IMPORTANT: Make sure to say "No" when asked "Instance has persistent volumes, do you want to destroy them? [y/N]?:"    
    
Recreate and redeploy the a new instance using the steps in "Create the server and deploy the application."
The first three steps are required (create, bootstrap, deploy). Rubber will attach and mount the existing EBS
volumes during the bootstrap. Rubber will not format or overwrite data on an existing EBS volume.

##Recovering if the EBS volume is lost or corrupted
Connect to the instance with the corrupted EBS volume via SSH. Stop all tasks using the EBS volume and
unmount the volume.

    service monit stop
    service munin-node stop
    service nginx stop
    service mysql stop
    umount /ebs

Using AWS web-based console:

* Detach and delete the corrupted EBS volume
* Create a new EBS volume from the most recent nightly snapshot. Make a note
of the new volume ID.
* Attach the volume to the instance. Make sure to attach it to the same device location as
the previous volume (typically Rubber uses /dev/sdh)

Edit instance-production.yml and put the new volume ID in the indicated locations

    - !ruby/object:Rubber::Configuration::InstanceItem 
      domain: collagewall.com
      external_host: ec2-50-17-81-168.compute-1.amazonaws.com
      .
      .
      .
      static_ip: 50.16.189.180
      volumes: 
      - vol-7034c21a  <<== new volume ID goes here
      zone: us-east-1b
    - volumes: 
        cwa2_/dev/sdh: vol-7034c21a  <<== new volume ID goes here
      static_ips: 
        cwa2: 50.16.189.180

Mount the new volume and restart everything

    mount /ebs
    service mysql start
    service nginx start
    service munin-node start
    service monit start

Deploy the app to push up the changes to instance-production.yml

    bundle exec cap deploy

##Recovering if both the instance and the EBS volume are lost
NOTE: This procedure can also be used to just restore a corrupt EBS volume. It's simpler
but takes longer than the previous method.

Tell Rubber the instance has crashed by destroying it.

    bundle exec cap rubber:destroy

Say "No" when asked "Instance has persistent volumes, do you want to destroy them? [y/N]?:"
This leaves the volume setting in instance-production.yml which we can use later.

Using AWS web-based console

* Delete the corrupted EBS volume
* Create a new EBS volume from the most recent nightly snapshot. Make a note of the new volume ID

Edit instance-production.yml and put the new volume ID under the "volumes:" section

    - volumes: 
        cwa2_/dev/sdh: vol-46de282c <<== new volume ID goes here
      static_ips: 
        cwa2: 50.16.189.180

Recreate and redeploy a new instance using the steps in "Create the server and deploy the application."
The first three steps are required (create, bootstrap, deploy). Rubber will attach and mount the new EBS
volume during the bootstrap. All data will be restored to the state of the most recent backup.